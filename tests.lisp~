(in-package #:little-zmq)

(cffi:defcstruct time-spec
  "Time Spec"
  (seconds :int)
  (nano :long))

(cffi:defcfun "clock_getres" :int
  "Get clock precision"
  (clock-id :int)
  (timespec :pointer))

(cffi:defcfun "clock_gettime" :int
  "Get clock time"
  (clock-id :int)
  (timespec :pointer))

(cffi:defcfun "clock_settime" :int
  "Set clock time"
  (clock-id :int)
  (timespec :pointer))

(defvar clock-realtime 0)
(defvar clock-monotonic 1)
(defvar clock-process-cputime-id 2)
(defvar clock-thread-cputime-id 3)
(defvar clock-monotonic-raw 4)
(defvar clock-realtime-coarse 5)
(defvar clock-monotonic-coarse 6)
(defvar clock-boottime 7)
(defvar clock-realtime-alarm 8)

(defun get-clock-time (clock-id)
  (cffi:with-foreign-object (tspec 'time-spec)
    (let ((ret (clock-gettime clock-id tspec)))
      (if (zerop ret)
	  (values (cffi:foreign-slot-value tspec 'time-spec 'seconds)
		  (cffi:foreign-slot-value tspec 'time-spec 'nano))
	  (error "Error raise in C call")))))

(defun set-clock-time (clock-id seconds nano-seconds)
  (cffi:with-foreign-object (tspec 'time-spec)
    (setf (cffi:foreign-slot-value tspec 'time-spec 'seconds) seconds
	  (cffi:foreign-slot-value tspec 'time-spec 'nano) nano-seconds)
    (unless (zerop (clock-settime clock-id tspec))
      (error "Error raised in C call"))))

(defun get-clock-res (clock-id)
  (cffi:with-foreign-object (tspec 'time-spec)
    (let ((ret (clock-getres clock-id tspec)))
      (if (zerop ret)
	  (values (cffi:foreign-slot-value tspec 'time-spec 'seconds)
		  (cffi:foreign-slot-value tspec 'time-spec 'nano))
	  (error "Error raise in C call")))))


(defun make-worker (ctx message-count)
  (declare (type fixnum  message-count))
  (lambda ()
    (with-socket ((rep ctx :rep) :connect "inproc://lat_test")
      (let ((msg (make-message)))
	(dotimes (i message-count)
	  (with-zmq-eintr-retry
	    (sendmsg rep (recvmsg rep :reuse-msg msg))))))))

(defmacro with-stopwatch (&body body)
  (alexandria:with-gensyms (ips)
    `(let* ((,ips (expt 10 9)))
       (multiple-value-bind (sec nano)
	   (get-clock-time clock-realtime)
	 ,@body	 
	 (multiple-value-bind (esec enano)
	     (get-clock-time clock-realtime)  
	   (+ (* ,ips (- esec sec)) (- enano nano)))))))

(defun inproc-lat (message-size message-count)
  (declare (type fixnum message-size message-count))
  (with-context (ctx 1)
    (with-socket ((req ctx :req) :bind "inproc://lat_test")
      (let ((worker (bt:make-thread (make-worker ctx message-count)
				    :name "worker"))
	    (msg (make-message message-size)))
	(declare (ignore worker))
	(print (/ (/ (with-stopwatch
		       (dotimes (x message-count)
			 (with-zmq-eintr-retry			   
			   (sendmsg req msg))
			 (with-zmq-eintr-retry
			   (setf msg (recvmsg req :reuse-msg msg)))))
		     1000)
		  (* message-count 2.0)))))))

(defun test ()
  (with-context (ctx)
    (with-sockets (((rep ctx :rep) :bind "inproc://testa")
		   ((req ctx :req) :connect "inproc://testa"))
      (let ((msg (make-octet-message
		  (make-array 5 :element-type '(unsigned-byte 8)
				:initial-contents '(1 2 3 4 5)))))
	(sendmsg req msg)
	(let ((ret (recvmsg rep :message-type 'octet-message)))
	  (print (data ret)))))))

(defun poll-test ()
  (with-context (ctx)
    (with-sockets (((rep ctx :rep) :bind "inproc://test")
		   ((req ctx :req) :connect "inproc://test"))
      (let ((msg-count 100)
	    (msg (make-octet-message
		  (make-array 5 :element-type '(unsigned-byte 8)
				:initial-contents '(1 2 3 4 5)))))
	(sendmsg req msg)
	(block end
	  (%zmq::with-polls (((rep :pollin
				   (lambda (skt revents)
				     (declare (ignore revents))
				     (print "polling rep")
				     (let ((ret (recvmsg skt
							 :message-type
							 'octet-message)))
				       (print (data ret))
				       (sendmsg skt ret))))
			      (req :pollin
				   (lambda (skt revents)
				     (declare (ignore revents))
				     (print "polling req")
				     (let ((ret (recvmsg skt
							 :message-type
							 'octet-message)))
				       (print (data ret))
				       (when (zerop (decf msg-count))
					 (return-from end))
				       (sendmsg skt ret)))))
			     :timeout 1000
			     :loop t)))))))